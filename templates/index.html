<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ‘çš„è¿½ç•ªç®¡ç†é¢æ¿</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <header>
        <h1>æˆ‘çš„è¿½ç•ªç®¡ç†é¢æ¿</h1>
        <div class="header-buttons">
            <button id="refresh-seasonal-button" onclick="refreshSeasonal()">åˆ·æ–°å½“å­£æ–°ç•ª</button>
            <button id="use-bangumi-button" onclick="useBangumiData()">ä½¿ç”¨Bangumiæ•°æ®</button>
            <button id="search-morning-button" onclick="searchTorrents()">æ‰§è¡Œæœç´¢</button>
            <button id="download-button" onclick="startDownload()">å¯åŠ¨ä¸‹è½½</button>
            <button id="toggle-log-button" onclick="toggleLogViewer()">æŸ¥çœ‹æ—¥å¿—</button>
            <button id="save-button" onclick="saveWatchlist()">ä¿å­˜è¿½ç•ªåˆ—è¡¨</button>
        </div>
    </header>

    <!-- æ—¥å¿—æŸ¥çœ‹å™¨ (é»˜è®¤éšè—) -->
    <div id="log-viewer" class="log-viewer hidden">
        <div class="log-header">
            <h3>ç³»ç»Ÿæ—¥å¿—</h3>
            <div class="log-controls">
                <button onclick="refreshLogs()">åˆ·æ–°æ—¥å¿—</button>
                <button onclick="clearLogDisplay()">æ¸…ç©ºæ˜¾ç¤º</button>
                <button onclick="toggleLogViewer()">å…³é—­</button>
            </div>
        </div>
        <pre id="log-content">åŠ è½½ä¸­...</pre>
    </div>

    <!-- æœç´¢å…³é”®è¯ç¼–è¾‘å™¨ (é»˜è®¤éšè—) -->
    <div id="search-keys-editor" class="modal hidden">
        <div class="modal-content">
            <h3>ç¼–è¾‘æœç´¢å…³é”®è¯</h3>
            <p>ç•ªå‰§: <strong id="editor-anime-title"></strong></p>
            <div id="search-keys-inputs"></div>
            <button onclick="addSearchKeyInput()">+ æ·»åŠ å…³é”®è¯</button>
            <div class="modal-buttons">
                <button onclick="saveSearchKeys()">ä¿å­˜</button>
                <button onclick="closeSearchKeysEditor()">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- ç•ªå‰§è¯¦æƒ…æŸ¥çœ‹å™¨ (é»˜è®¤éšè—) -->
    <div id="anime-detail-viewer" class="modal hidden">
        <div class="modal-content anime-detail large-modal">
            <div class="detail-header">
                <h3 id="detail-title">ç•ªå‰§è¯¦æƒ…</h3>
                <button class="close-btn" onclick="closeAnimeDetail()">âœ•</button>
            </div>
            <div class="detail-body">
                <div class="detail-left">
                    <img id="detail-cover" src="" alt="å°é¢">
                    <div class="detail-stats">
                        <div class="stat-item">
                            <span class="stat-label">è¯„åˆ†:</span>
                            <span class="stat-value" id="detail-rating">-</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">æ’å:</span>
                            <span class="stat-value" id="detail-rank">-</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">é›†æ•°:</span>
                            <span class="stat-value" id="detail-eps">-</span>
                        </div>
                    </div>
                </div>
                <div class="detail-right">
                    <div class="detail-info">
                        <p><strong>æ—¥æ–‡å:</strong> <span id="detail-jp-name">-</span></p>
                        <p><strong>æ”¾é€æ—¥æœŸ:</strong> <span id="detail-air-date">-</span></p>
                        <p><strong>å®˜ç½‘:</strong> <a id="detail-site" href="#" target="_blank">æŸ¥çœ‹</a></p>
                        <p><strong>Bangumi ID:</strong> <span id="detail-bangumi-id">-</span></p>
                    </div>
                    <div class="detail-summary">
                        <h4>ç®€ä»‹</h4>
                        <p id="detail-summary-text">æš‚æ— ç®€ä»‹</p>
                    </div>
                    <div class="detail-collection">
                        <h4>æ”¶è—ç»Ÿè®¡</h4>
                        <div class="collection-stats">
                            <span>æƒ³çœ‹: <strong id="detail-wish">0</strong></span>
                            <span>åœ¨çœ‹: <strong id="detail-doing">0</strong></span>
                            <span>çœ‹è¿‡: <strong id="detail-collect">0</strong></span>
                            <span>æç½®: <strong id="detail-hold">0</strong></span>
                            <span>æŠ›å¼ƒ: <strong id="detail-drop">0</strong></span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- æ ‡ç­¾é¡µå¯¼èˆª -->
            <div class="detail-tabs">
                <button class="tab-btn active" onclick="switchTab('episodes')">ç« èŠ‚åˆ—è¡¨</button>
                <button class="tab-btn" onclick="switchTab('characters')">è§’è‰²å£°ä¼˜</button>
                <button class="tab-btn" onclick="switchTab('staff')">åˆ¶ä½œäººå‘˜</button>
                <button class="tab-btn" onclick="switchTab('relations')">å…³è”æ¡ç›®</button>
                <button class="tab-btn" onclick="switchTab('topics')">è®¨è®ºåŒº</button>
                <button class="tab-btn" onclick="switchTab('comments')">ç”¨æˆ·è¯„è®º</button>
            </div>
            
            <!-- æ ‡ç­¾é¡µå†…å®¹ -->
            <div class="detail-tabs-content">
                <!-- ç« èŠ‚åˆ—è¡¨ -->
                <div id="tab-episodes" class="tab-content active">
                    <div class="loading" id="episodes-loading">åŠ è½½ä¸­...</div>
                    <div id="episodes-list" class="episodes-list"></div>
                </div>
                
                <!-- è§’è‰²å£°ä¼˜ -->
                <div id="tab-characters" class="tab-content">
                    <div class="loading" id="characters-loading">åŠ è½½ä¸­...</div>
                    <div id="characters-list" class="characters-list"></div>
                </div>
                
                <!-- åˆ¶ä½œäººå‘˜ -->
                <div id="tab-staff" class="tab-content">
                    <div class="loading" id="staff-loading">åŠ è½½ä¸­...</div>
                    <div id="staff-list" class="staff-list"></div>
                </div>
                
                <!-- å…³è”æ¡ç›® -->
                <div id="tab-relations" class="tab-content">
                    <div class="loading" id="relations-loading">åŠ è½½ä¸­...</div>
                    <div id="relations-list" class="relations-list"></div>
                </div>
                
                <!-- è®¨è®ºåŒº -->
                <div id="tab-topics" class="tab-content">
                    <div class="loading" id="topics-loading">åŠ è½½ä¸­...</div>
                    <div id="topics-list" class="topics-list"></div>
                </div>
                
                <!-- ç”¨æˆ·è¯„è®º -->
                <div id="tab-comments" class="tab-content">
                    <div class="loading" id="comments-loading">åŠ è½½ä¸­...</div>
                    <div id="comments-list" class="comments-list"></div>
                </div>
            </div>
        </div>
    </div>

    <main id="anime-list-container">
        <p>æ­£åœ¨åŠ è½½æ–°ç•ªåˆ—è¡¨ä¸­...</p>
    </main>

    <script>
        let currentSearchConfig = {}; // å­˜å‚¨å½“å‰çš„æœç´¢é…ç½®
        let currentEditingAnime = null; // å½“å‰æ­£åœ¨ç¼–è¾‘çš„ç•ªå‰§

        // 1. é¡µé¢åŠ è½½æ—¶, ç«‹å³è·å–æ•°æ®
        window.onload = function() {
            loadData();
            loadSearchConfig();
        };

        function loadData() {
            fetch('/api/data')
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert("åŠ è½½æ•°æ®å¤±è´¥: " + data.error);
                        document.getElementById('anime-list-container').innerHTML = `<p style="color:red;">${data.error}</p>`;
                        return;
                    }
                    renderAnimeList(data.grouped_anime, data.current_watchlist, data.weekdays_order);
                })
                .catch(err => {
                    console.error("Fetch error:", err);
                    alert("åŠ è½½æ•°æ®å¤±è´¥ï¼Œè¯·æ£€æŸ¥ app.py æœåŠ¡å™¨æ˜¯å¦æ­£åœ¨è¿è¡Œã€‚");
                });
        }

        function loadSearchConfig() {
            fetch('/api/get_search_config')
                .then(response => response.json())
                .then(data => {
                    currentSearchConfig = data;
                })
                .catch(err => {
                    console.error("è·å–æœç´¢é…ç½®å¤±è´¥:", err);
                });
        }

        // 2. å°†æ•°æ®æ¸²æŸ“ä¸º HTML
        function renderAnimeList(groupedAnime, watchlist, weekdays_order) {
            const container = document.getElementById('anime-list-container');
            container.innerHTML = ''; // æ¸…ç©º"åŠ è½½ä¸­"æç¤º

            // å¤–å±‚å¾ªç¯: éå†å‘¨å‡  (æŒ‰é¡ºåº)
            weekdays_order.forEach(day => {
                const animeForThisDay = groupedAnime[day];
                
                // 1. åˆ›å»ºç«–å‘çš„ "å¤©" åˆ—
                const dayColumn = document.createElement('div');
                dayColumn.className = 'day-column';
                
                // 2. åˆ›å»ºå‘¨å‡ çš„æ ‡é¢˜
                const heading = document.createElement('h2');
                heading.className = 'day-heading';
                heading.textContent = `${day} (å…± ${animeForThisDay.length} éƒ¨)`;
                dayColumn.appendChild(heading);

                // 3. åˆ›å»ºè¯¥åˆ—ä¸­ç”¨äºå­˜æ”¾å¡ç‰‡çš„åˆ—è¡¨
                const cardList = document.createElement('div');
                cardList.className = 'card-list';

                // å†…å±‚å¾ªç¯: éå†å½“å¤©çš„æ‰€æœ‰ç•ªå‰§, å¹¶åˆ›å»ºå¡ç‰‡
                animeForThisDay.forEach(anime => {
                    const isChecked = watchlist.includes(anime.primary_title);
                    
                    const card = document.createElement('div');
                    card.className = 'anime-card';
                    
                    const broadcastTime = `(${anime.begin_time} JST)`;
                    
                    // æ˜¾ç¤ºè¯„åˆ†å’Œæ’åï¼ˆå¦‚æœæœ‰ï¼‰
                    const rating = anime.rating?.score || 'N/A';
                    const rank = anime.rank || 'N/A';
                    const hasDetails = anime.bangumi_id || anime.rating || anime.summary;

                    card.innerHTML = `
                        <div class="anime-card-header">
                            <input 
                                type="checkbox" 
                                id="${anime.primary_title}" 
                                value="${anime.primary_title}"
                                ${isChecked ? 'checked' : ''}
                            >
                            <label for="${anime.primary_title}">
                                <span class="title">${anime.primary_title}</span>
                                <span class="broadcast-time">${broadcastTime}</span>
                            </label>
                        </div>
                        ${hasDetails ? `
                            <div class="anime-meta">
                                <span class="meta-item">è¯„åˆ†: ${rating}</span>
                                <span class="meta-item">æ’å: #${rank}</span>
                                ${anime.bangumi_id ? `<button class="detail-btn" onclick="showAnimeDetail('${anime.primary_title}')">è¯¦æƒ…</button>` : ''}
                            </div>
                        ` : ''}
                        ${isChecked ? `<button class="edit-search-btn" onclick="openSearchKeysEditor('${anime.primary_title}')">ç¼–è¾‘æœç´¢è¯</button>` : ''}
                    `;
                    
                    cardList.appendChild(card);
                });
                
                dayColumn.appendChild(cardList);
                container.appendChild(dayColumn);
            });
            
            // ä¿å­˜å®Œæ•´çš„åŠ¨ç”»æ•°æ®ä¾›è¯¦æƒ…æŸ¥çœ‹ä½¿ç”¨
            window.allAnimeData = {};
            weekdays_order.forEach(day => {
                groupedAnime[day].forEach(anime => {
                    window.allAnimeData[anime.primary_title] = anime;
                });
            });
        }
        
        // 3. ä¿å­˜æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
        function saveWatchlist() {
            const button = document.getElementById('save-button');
            button.disabled = true;
            button.textContent = 'ä¿å­˜ä¸­...';

            const allCheckboxes = document.querySelectorAll('.anime-card input[type="checkbox"]');
            const selectedTitles = [];
            
            allCheckboxes.forEach(checkbox => {
                if (checkbox.checked) {
                    selectedTitles.push(checkbox.value);
                }
            });

            // 4. å°†å‹¾é€‰çš„åˆ—è¡¨å‘é€å› Python æœåŠ¡å™¨
            fetch('/api/save_watchlist', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ selected_titles: selectedTitles }),
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    alert(data.message);
                    // é‡æ–°åŠ è½½æ•°æ®ä»¥æ›´æ–°ç•Œé¢
                    loadData();
                    loadSearchConfig();
                } else {
                    alert('ä¿å­˜å¤±è´¥: ' + data.error);
                }
                button.disabled = false;
                button.textContent = 'ä¿å­˜è¿½ç•ªåˆ—è¡¨';
            })
            .catch(err => {
                console.error("Save error:", err);
                alert("ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ app.py æœåŠ¡å™¨ã€‚");
                button.disabled = false;
                button.textContent = 'ä¿å­˜è¿½ç•ªåˆ—è¡¨';
            });
        }

        // æ–°å¢åŠŸèƒ½ï¼šåˆ·æ–°å½“å­£æ–°ç•ª
        function refreshSeasonal() {
            const button = document.getElementById('refresh-seasonal-button');
            button.disabled = true;
            button.textContent = 'åˆ·æ–°ä¸­...';

            fetch('/api/refresh_seasonal', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    alert(data.message);
                    // åˆ·æ–°é¡µé¢æ•°æ®
                    loadData();
                } else {
                    alert('åˆ·æ–°å¤±è´¥: ' + data.error);
                }
                button.disabled = false;
                button.textContent = 'åˆ·æ–°å½“å­£æ–°ç•ª';
            })
            .catch(err => {
                console.error("Refresh error:", err);
                alert("åˆ·æ–°å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨ã€‚");
                button.disabled = false;
                button.textContent = 'åˆ·æ–°å½“å­£æ–°ç•ª';
            });
        }

        // æ–°å¢åŠŸèƒ½ï¼šæ‰§è¡Œæœç´¢
        function searchTorrents() {
            const button = document.getElementById('search-morning-button');
            button.disabled = true;
            button.textContent = 'æœç´¢ä¸­...';

            fetch('/api/search_torrents', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // æ˜¾ç¤ºå®Œæ•´è¾“å‡º
                    alert(data.message + '\n\nå®Œæ•´è¾“å‡º:\n' + data.output);
                } else {
                    alert('æœç´¢å¤±è´¥: ' + data.error);
                }
                button.disabled = false;
                button.textContent = 'æ‰§è¡Œæœç´¢';
            })
            .catch(err => {
                console.error("Search error:", err);
                alert("æœç´¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨ã€‚");
                button.disabled = false;
                button.textContent = 'æ‰§è¡Œæœç´¢';
            });
        }

        // æ–°å¢åŠŸèƒ½ï¼šå¯åŠ¨ä¸‹è½½
        function startDownload() {
            if (!confirm('ç¡®å®šè¦å¯åŠ¨ä¸‹è½½ä»»åŠ¡å—ï¼Ÿè¿™å¯èƒ½éœ€è¦è¾ƒé•¿æ—¶é—´ã€‚')) {
                return;
            }

            const button = document.getElementById('download-button');
            button.disabled = true;
            button.textContent = 'ä¸‹è½½ä¸­...';

            fetch('/api/start_download', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // æ˜¾ç¤ºå®Œæ•´è¾“å‡º
                    alert(data.message + '\n\nå®Œæ•´è¾“å‡º:\n' + data.output);
                } else {
                    alert('ä¸‹è½½å¤±è´¥: ' + data.error);
                }
                button.disabled = false;
                button.textContent = 'å¯åŠ¨ä¸‹è½½';
            })
            .catch(err => {
                console.error("Download error:", err);
                alert("ä¸‹è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨ã€‚");
                button.disabled = false;
                button.textContent = 'å¯åŠ¨ä¸‹è½½';
            });
        }

        // æ–°å¢åŠŸèƒ½ï¼šæ˜¾ç¤º/éšè—æ—¥å¿—æŸ¥çœ‹å™¨
        function toggleLogViewer() {
            const logViewer = document.getElementById('log-viewer');
            logViewer.classList.toggle('hidden');
            
            if (!logViewer.classList.contains('hidden')) {
                refreshLogs();
            }
        }

        // æ–°å¢åŠŸèƒ½ï¼šåˆ·æ–°æ—¥å¿—
        function refreshLogs() {
            const logContent = document.getElementById('log-content');
            logContent.textContent = 'åŠ è½½ä¸­...';

            fetch('/api/get_logs?lines=100') // è·å–æœ€å100è¡Œ
            .then(response => response.json())
            .then(data => {
                if (data.exists) {
                    logContent.textContent = data.content || 'æ—¥å¿—ä¸ºç©º';
                    // è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
                    logContent.scrollTop = logContent.scrollHeight;
                } else {
                    logContent.textContent = data.content;
                }
            })
            .catch(err => {
                console.error("Load logs error:", err);
                logContent.textContent = 'åŠ è½½æ—¥å¿—å¤±è´¥';
            });
        }

        // æ–°å¢åŠŸèƒ½ï¼šæ¸…ç©ºæ—¥å¿—æ˜¾ç¤º
        function clearLogDisplay() {
            document.getElementById('log-content').textContent = '';
        }

        // æ–°å¢åŠŸèƒ½ï¼šæ‰“å¼€æœç´¢å…³é”®è¯ç¼–è¾‘å™¨
        function openSearchKeysEditor(animeTitle) {
            currentEditingAnime = animeTitle;
            const editor = document.getElementById('search-keys-editor');
            const titleElement = document.getElementById('editor-anime-title');
            const inputsContainer = document.getElementById('search-keys-inputs');
            
            titleElement.textContent = animeTitle;
            inputsContainer.innerHTML = '';
            
            // è·å–å½“å‰æœç´¢å…³é”®è¯
            const searchKeys = currentSearchConfig[animeTitle]?.search_keys || [animeTitle, '1080p'];
            
            // ä¸ºæ¯ä¸ªå…³é”®è¯åˆ›å»ºè¾“å…¥æ¡†
            searchKeys.forEach((key, index) => {
                const inputDiv = document.createElement('div');
                inputDiv.className = 'search-key-input-group';
                inputDiv.innerHTML = `
                    <input type="text" value="${key}" data-index="${index}" />
                    <button onclick="removeSearchKeyInput(${index})">åˆ é™¤</button>
                `;
                inputsContainer.appendChild(inputDiv);
            });
            
            editor.classList.remove('hidden');
        }

        // æ–°å¢åŠŸèƒ½ï¼šæ·»åŠ æœç´¢å…³é”®è¯è¾“å…¥æ¡†
        function addSearchKeyInput() {
            const inputsContainer = document.getElementById('search-keys-inputs');
            const currentInputs = inputsContainer.querySelectorAll('input');
            const index = currentInputs.length;
            
            const inputDiv = document.createElement('div');
            inputDiv.className = 'search-key-input-group';
            inputDiv.innerHTML = `
                <input type="text" value="" data-index="${index}" placeholder="è¾“å…¥æœç´¢å…³é”®è¯" />
                <button onclick="removeSearchKeyInput(${index})">åˆ é™¤</button>
            `;
            inputsContainer.appendChild(inputDiv);
        }

        // æ–°å¢åŠŸèƒ½ï¼šåˆ é™¤æœç´¢å…³é”®è¯è¾“å…¥æ¡†
        function removeSearchKeyInput(index) {
            const inputsContainer = document.getElementById('search-keys-inputs');
            const inputs = inputsContainer.querySelectorAll('.search-key-input-group');
            if (inputs.length > 1) {
                inputs[index].remove();
                // é‡æ–°ç¼–å·
                inputsContainer.querySelectorAll('input').forEach((input, i) => {
                    input.setAttribute('data-index', i);
                });
            } else {
                alert('è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªæœç´¢å…³é”®è¯ï¼');
            }
        }

        // æ–°å¢åŠŸèƒ½ï¼šä¿å­˜æœç´¢å…³é”®è¯
        function saveSearchKeys() {
            const inputsContainer = document.getElementById('search-keys-inputs');
            const inputs = inputsContainer.querySelectorAll('input');
            const searchKeys = Array.from(inputs).map(input => input.value.trim()).filter(v => v);
            
            if (searchKeys.length === 0) {
                alert('è‡³å°‘éœ€è¦ä¸€ä¸ªæœç´¢å…³é”®è¯ï¼');
                return;
            }
            
            fetch('/api/update_search_keys', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    title: currentEditingAnime,
                    search_keys: searchKeys
                }),
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    alert(data.message);
                    closeSearchKeysEditor();
                    loadSearchConfig();
                } else {
                    alert('ä¿å­˜å¤±è´¥: ' + data.error);
                }
            })
            .catch(err => {
                console.error("Save search keys error:", err);
                alert("ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨ã€‚");
            });
        }

        // æ–°å¢åŠŸèƒ½ï¼šå…³é—­æœç´¢å…³é”®è¯ç¼–è¾‘å™¨
        function closeSearchKeysEditor() {
            document.getElementById('search-keys-editor').classList.add('hidden');
            currentEditingAnime = null;
        }

        // æ–°å¢åŠŸèƒ½ï¼šä½¿ç”¨ Bangumi API æ•°æ®
        function useBangumiData() {
            if (!confirm('ä½¿ç”¨ Bangumi API æ•°æ®å°†æ›¿æ¢å½“å‰çš„ç•ªå‰§åˆ—è¡¨ï¼Œç¡®å®šç»§ç»­å—ï¼Ÿ')) {
                return;
            }

            const button = document.getElementById('use-bangumi-button');
            button.disabled = true;
            button.textContent = 'è·å–ä¸­...';

            fetch('/api/use_bangumi_calendar', {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    alert(data.message);
                    // åˆ·æ–°é¡µé¢æ•°æ®
                    loadData();
                } else {
                    alert('è·å–å¤±è´¥: ' + data.error);
                }
                button.disabled = false;
                button.textContent = 'ä½¿ç”¨Bangumiæ•°æ®';
            })
            .catch(err => {
                console.error("Bangumi API error:", err);
                alert("è·å–å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨ã€‚");
                button.disabled = false;
                button.textContent = 'ä½¿ç”¨Bangumiæ•°æ®';
            });
        }

        // æ–°å¢åŠŸèƒ½ï¼šæ˜¾ç¤ºç•ªå‰§è¯¦æƒ…
        function showAnimeDetail(animeTitle) {
            const anime = window.allAnimeData[animeTitle];
            if (!anime) {
                alert('æ— æ³•æ‰¾åˆ°ç•ªå‰§ä¿¡æ¯');
                return;
            }

            // ä¿å­˜å½“å‰ç•ªå‰§IDä¾›åç»­ä½¿ç”¨
            window.currentAnimeDetail = anime;

            // å¡«å……è¯¦æƒ…ä¿¡æ¯
            document.getElementById('detail-title').textContent = anime.primary_title;
            document.getElementById('detail-jp-name').textContent = anime.jp_name || '-';
            document.getElementById('detail-air-date').textContent = `${anime.begin_date} ${anime.weekday} ${anime.begin_time}`;
            document.getElementById('detail-bangumi-id').textContent = anime.bangumi_id || '-';
            
            // å°é¢å›¾
            const coverImg = document.getElementById('detail-cover');
            if (anime.images && anime.images.large) {
                coverImg.src = anime.images.large;
                coverImg.style.display = 'block';
            } else {
                coverImg.style.display = 'none';
            }

            // è¯„åˆ†ä¿¡æ¯
            document.getElementById('detail-rating').textContent = anime.rating?.score || '-';
            document.getElementById('detail-rank').textContent = anime.rank ? `#${anime.rank}` : '-';
            document.getElementById('detail-eps').textContent = anime.eps_count || '-';

            // ç®€ä»‹
            document.getElementById('detail-summary-text').textContent = anime.summary || 'æš‚æ— ç®€ä»‹';

            // å®˜ç½‘é“¾æ¥
            const siteLink = document.getElementById('detail-site');
            if (anime.site) {
                siteLink.href = anime.site;
                siteLink.style.display = 'inline';
            } else {
                siteLink.style.display = 'none';
            }

            // æ”¶è—ç»Ÿè®¡
            if (anime.collection) {
                document.getElementById('detail-wish').textContent = anime.collection.wish || 0;
                document.getElementById('detail-doing').textContent = anime.collection.doing || 0;
                document.getElementById('detail-collect').textContent = anime.collection.collect || 0;
                document.getElementById('detail-hold').textContent = anime.collection.on_hold || 0;
                document.getElementById('detail-drop').textContent = anime.collection.dropped || 0;
            }

            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            document.getElementById('anime-detail-viewer').classList.remove('hidden');
            
            // åˆ‡æ¢åˆ°ç« èŠ‚æ ‡ç­¾å¹¶åŠ è½½æ•°æ®
            switchTab('episodes');
        }

        // æ ‡ç­¾åˆ‡æ¢
        function switchTab(tabName) {
            // æ›´æ–°æ ‡ç­¾æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // æ›´æ–°å†…å®¹æ˜¾ç¤º
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            // åŠ è½½å¯¹åº”æ•°æ®
            const anime = window.currentAnimeDetail;
            if (!anime || !anime.bangumi_id) return;
            
            switch(tabName) {
                case 'episodes':
                    loadEpisodes(anime.bangumi_id);
                    break;
                case 'characters':
                    loadCharacters(anime.bangumi_id);
                    break;
                case 'staff':
                    loadStaff(anime.bangumi_id);
                    break;
                case 'relations':
                    loadRelations(anime.bangumi_id);
                    break;
                case 'topics':
                    loadTopics(anime.bangumi_id);
                    break;
                case 'comments':
                    loadComments(anime.bangumi_id);
                    break;
            }
        }

        // åŠ è½½ç« èŠ‚åˆ—è¡¨
        async function loadEpisodes(subjectId) {
            const container = document.getElementById('episodes-list');
            const loading = document.getElementById('episodes-loading');
            
            loading.style.display = 'block';
            container.innerHTML = '';
            
            try {
                const response = await fetch(`/api/bangumi/episodes/${subjectId}`);
                const result = await response.json();
                
                loading.style.display = 'none';
                
                if (result.status === 'success' && result.data.length > 0) {
                    const episodes = result.data;
                    
                    // æ·»åŠ æ‰¹é‡æ“ä½œæŒ‰é’®
                    const toolbar = document.createElement('div');
                    toolbar.className = 'episodes-toolbar';
                    toolbar.innerHTML = `
                        <button class="toolbar-btn" onclick="markAllEpisodesWatched(${subjectId})">
                            âœ“ å…¨éƒ¨æ ‡è®°ä¸ºå·²çœ‹
                        </button>
                        <button class="toolbar-btn" onclick="markAllEpisodesUnwatched(${subjectId})">
                            âœ— å…¨éƒ¨æ ‡è®°ä¸ºæœªçœ‹
                        </button>
                    `;
                    container.appendChild(toolbar);
                    
                    episodes.forEach(ep => {
                        const epDiv = document.createElement('div');
                        epDiv.className = 'episode-item';
                        epDiv.id = `episode-${ep.id}`;
                        epDiv.innerHTML = `
                            <div class="episode-checkbox">
                                <input type="checkbox" id="ep-check-${ep.id}" 
                                    onchange="toggleEpisodeStatus(${subjectId}, ${ep.id}, this.checked)">
                            </div>
                            <div class="episode-number">EP ${ep.ep || ep.sort}</div>
                            <div class="episode-info">
                                <div class="episode-title">${ep.name_cn || ep.name || 'æœªå‘½å'}</div>
                                <div class="episode-meta">
                                    ${ep.airdate ? `æ”¾é€æ—¥æœŸ: ${ep.airdate}` : ''}
                                    ${ep.duration ? ` | æ—¶é•¿: ${ep.duration}` : ''}
                                </div>
                                ${ep.desc ? `<div class="episode-desc">${ep.desc}</div>` : ''}
                            </div>
                            <div class="episode-actions">
                                <button class="ep-comment-btn" onclick="viewEpisodeComments(${ep.id})" title="æŸ¥çœ‹æœ¬é›†åæ§½">
                                    ğŸ’¬
                                </button>
                            </div>
                        `;
                        container.appendChild(epDiv);
                    });
                    
                    // å¦‚æœæœ‰ç”¨æˆ· tokenï¼ŒåŠ è½½è§‚çœ‹çŠ¶æ€
                    loadEpisodeWatchStatus(subjectId);
                } else {
                    container.innerHTML = '<p class="no-data">æš‚æ— ç« èŠ‚ä¿¡æ¯</p>';
                }
            } catch (error) {
                loading.style.display = 'none';
                container.innerHTML = '<p class="error">åŠ è½½å¤±è´¥</p>';
                console.error('åŠ è½½ç« èŠ‚å¤±è´¥:', error);
            }
        }

        // åŠ è½½ç« èŠ‚è§‚çœ‹çŠ¶æ€ï¼ˆéœ€è¦ç”¨æˆ·è®¤è¯ï¼‰
        async function loadEpisodeWatchStatus(subjectId) {
            // è¿™é‡Œéœ€è¦ç”¨æˆ·åï¼Œå¯ä»¥ä»é…ç½®ä¸­è·å–æˆ–è®©ç”¨æˆ·è®¾ç½®
            // æš‚æ—¶è·³è¿‡ï¼Œå› ä¸ºéœ€è¦ç”¨æˆ·å
            console.log('è§‚çœ‹çŠ¶æ€åŠ è½½åŠŸèƒ½éœ€è¦é…ç½®ç”¨æˆ·å');
        }

        // åˆ‡æ¢ç« èŠ‚è§‚çœ‹çŠ¶æ€
        async function toggleEpisodeStatus(subjectId, episodeId, watched) {
            try {
                const type = watched ? 2 : 0; // 2=çœ‹è¿‡, 0=æœªæ”¶è—
                const response = await fetch(`/api/bangumi/episode/${subjectId}/${episodeId}/status`, {
                    method: 'PATCH',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({type: type})
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    console.log(`ç« èŠ‚ ${episodeId} çŠ¶æ€å·²æ›´æ–°ä¸º: ${watched ? 'å·²çœ‹' : 'æœªçœ‹'}`);
                } else {
                    alert('æ›´æ–°å¤±è´¥: ' + (result.error || 'æœªçŸ¥é”™è¯¯'));
                    // æ¢å¤å¤é€‰æ¡†çŠ¶æ€
                    document.getElementById(`ep-check-${episodeId}`).checked = !watched;
                }
            } catch (error) {
                console.error('æ›´æ–°ç« èŠ‚çŠ¶æ€å¤±è´¥:', error);
                alert('æ›´æ–°å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
                document.getElementById(`ep-check-${episodeId}`).checked = !watched;
            }
        }

        // æ‰¹é‡æ ‡è®°æ‰€æœ‰ç« èŠ‚ä¸ºå·²çœ‹
        async function markAllEpisodesWatched(subjectId) {
            const checkboxes = document.querySelectorAll('[id^="ep-check-"]');
            const episodeIds = Array.from(checkboxes).map(cb => {
                const id = cb.id.replace('ep-check-', '');
                return parseInt(id);
            });
            
            if (episodeIds.length === 0) return;
            
            try {
                const response = await fetch(`/api/bangumi/episodes/${subjectId}/batch-status`, {
                    method: 'PATCH',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({episode_ids: episodeIds, type: 2})
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    // æ›´æ–°æ‰€æœ‰å¤é€‰æ¡†çŠ¶æ€
                    checkboxes.forEach(cb => cb.checked = true);
                    alert('æ‰€æœ‰ç« èŠ‚å·²æ ‡è®°ä¸ºå·²çœ‹');
                } else {
                    alert('æ‰¹é‡æ›´æ–°å¤±è´¥: ' + (result.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('æ‰¹é‡æ›´æ–°å¤±è´¥:', error);
                alert('æ‰¹é‡æ›´æ–°å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }
        }

        // æ‰¹é‡æ ‡è®°æ‰€æœ‰ç« èŠ‚ä¸ºæœªçœ‹
        async function markAllEpisodesUnwatched(subjectId) {
            const checkboxes = document.querySelectorAll('[id^="ep-check-"]');
            const episodeIds = Array.from(checkboxes).map(cb => {
                const id = cb.id.replace('ep-check-', '');
                return parseInt(id);
            });
            
            if (episodeIds.length === 0) return;
            
            try {
                const response = await fetch(`/api/bangumi/episodes/${subjectId}/batch-status`, {
                    method: 'PATCH',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({episode_ids: episodeIds, type: 0})
                });
                
                const result = await response.json();
                if (result.status === 'success') {
                    // æ›´æ–°æ‰€æœ‰å¤é€‰æ¡†çŠ¶æ€
                    checkboxes.forEach(cb => cb.checked = false);
                    alert('æ‰€æœ‰ç« èŠ‚å·²æ ‡è®°ä¸ºæœªçœ‹');
                } else {
                    alert('æ‰¹é‡æ›´æ–°å¤±è´¥: ' + (result.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('æ‰¹é‡æ›´æ–°å¤±è´¥:', error);
                alert('æ‰¹é‡æ›´æ–°å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
            }
        }

        // æŸ¥çœ‹æŸé›†çš„è¯„è®º/åæ§½
        function viewEpisodeComments(episodeId) {
            // å¯ä»¥åˆ›å»ºä¸€ä¸ªæ¨¡æ€æ¡†æ˜¾ç¤ºç« èŠ‚è¯„è®ºï¼Œæˆ–ç›´æ¥æ‰“å¼€ Bangumi é¡µé¢
            window.open(`https://bgm.tv/ep/${episodeId}`, '_blank');
        }

        // åŠ è½½è§’è‰²å’Œå£°ä¼˜
        async function loadCharacters(subjectId) {
            const container = document.getElementById('characters-list');
            const loading = document.getElementById('characters-loading');
            
            loading.style.display = 'block';
            container.innerHTML = '';
            
            try {
                const response = await fetch(`/api/bangumi/characters/${subjectId}`);
                const result = await response.json();
                
                loading.style.display = 'none';
                
                if (result.status === 'success' && result.data.length > 0) {
                    const characters = result.data;
                    characters.forEach(char => {
                        const charDiv = document.createElement('div');
                        charDiv.className = 'character-item';
                        
                        const charInfo = char.character || {};
                        const actors = char.actors || [];
                        
                        charDiv.innerHTML = `
                            <div class="character-avatar">
                                ${charInfo.images?.medium ? `<img src="${charInfo.images.medium}" alt="${charInfo.name}">` : '<div class="no-avatar">æ— å¤´åƒ</div>'}
                            </div>
                            <div class="character-info">
                                <div class="character-name">${charInfo.name}</div>
                                <div class="character-role">${char.relation || 'è§’è‰²'}</div>
                                ${actors.length > 0 ? `
                                    <div class="character-cv">
                                        CV: ${actors.map(a => a.name).join(', ')}
                                    </div>
                                ` : ''}
                            </div>
                        `;
                        container.appendChild(charDiv);
                    });
                } else {
                    container.innerHTML = '<p class="no-data">æš‚æ— è§’è‰²ä¿¡æ¯</p>';
                }
            } catch (error) {
                loading.style.display = 'none';
                container.innerHTML = '<p class="error">åŠ è½½å¤±è´¥</p>';
                console.error('åŠ è½½è§’è‰²å¤±è´¥:', error);
            }
        }

        // åŠ è½½åˆ¶ä½œäººå‘˜
        async function loadStaff(subjectId) {
            const container = document.getElementById('staff-list');
            const loading = document.getElementById('staff-loading');
            
            loading.style.display = 'block';
            container.innerHTML = '';
            
            try {
                const response = await fetch(`/api/bangumi/persons/${subjectId}`);
                const result = await response.json();
                
                loading.style.display = 'none';
                
                if (result.status === 'success' && result.data.length > 0) {
                    const staff = result.data;
                    
                    // æŒ‰èŒä½åˆ†ç»„
                    const grouped = {};
                    staff.forEach(person => {
                        const role = person.relation || 'å…¶ä»–';
                        if (!grouped[role]) grouped[role] = [];
                        grouped[role].push(person);
                    });
                    
                    Object.keys(grouped).forEach(role => {
                        const roleSection = document.createElement('div');
                        roleSection.className = 'staff-section';
                        roleSection.innerHTML = `<h4>${role}</h4>`;
                        
                        const staffGrid = document.createElement('div');
                        staffGrid.className = 'staff-grid';
                        
                        grouped[role].forEach(person => {
                            const personInfo = person.person || {};
                            const personDiv = document.createElement('div');
                            personDiv.className = 'staff-item';
                            personDiv.innerHTML = `
                                <div class="staff-avatar">
                                    ${personInfo.images?.medium ? `<img src="${personInfo.images.medium}" alt="${personInfo.name}">` : '<div class="no-avatar">æ— å¤´åƒ</div>'}
                                </div>
                                <div class="staff-name">${personInfo.name}</div>
                            `;
                            staffGrid.appendChild(personDiv);
                        });
                        
                        roleSection.appendChild(staffGrid);
                        container.appendChild(roleSection);
                    });
                } else {
                    container.innerHTML = '<p class="no-data">æš‚æ— åˆ¶ä½œäººå‘˜ä¿¡æ¯</p>';
                }
            } catch (error) {
                loading.style.display = 'none';
                container.innerHTML = '<p class="error">åŠ è½½å¤±è´¥</p>';
                console.error('åŠ è½½åˆ¶ä½œäººå‘˜å¤±è´¥:', error);
            }
        }

        // åŠ è½½å…³è”æ¡ç›®
        async function loadRelations(subjectId) {
            const container = document.getElementById('relations-list');
            const loading = document.getElementById('relations-loading');
            
            loading.style.display = 'block';
            container.innerHTML = '';
            
            try {
                const response = await fetch(`/api/bangumi/relations/${subjectId}`);
                const result = await response.json();
                
                loading.style.display = 'none';
                
                if (result.status === 'success' && result.data.length > 0) {
                    const relations = result.data;
                    relations.forEach(rel => {
                        const relDiv = document.createElement('div');
                        relDiv.className = 'relation-item';
                        relDiv.innerHTML = `
                            <div class="relation-cover">
                                ${rel.images?.medium ? `<img src="${rel.images.medium}" alt="${rel.name}">` : '<div class="no-cover">æ— å°é¢</div>'}
                            </div>
                            <div class="relation-info">
                                <div class="relation-title">${rel.name_cn || rel.name}</div>
                                <div class="relation-type">${rel.relation || 'å…³è”ä½œå“'}</div>
                                ${rel.date ? `<div class="relation-date">${rel.date}</div>` : ''}
                            </div>
                        `;
                        container.appendChild(relDiv);
                    });
                } else {
                    container.innerHTML = '<p class="no-data">æš‚æ— å…³è”æ¡ç›®</p>';
                }
            } catch (error) {
                loading.style.display = 'none';
                container.innerHTML = '<p class="error">åŠ è½½å¤±è´¥</p>';
                console.error('åŠ è½½å…³è”æ¡ç›®å¤±è´¥:', error);
            }
        }

        // åŠ è½½è®¨è®ºè¯é¢˜
        async function loadTopics(subjectId) {
            const container = document.getElementById('topics-list');
            const loading = document.getElementById('topics-loading');
            
            loading.style.display = 'block';
            container.innerHTML = '';
            
            try {
                const response = await fetch(`/api/bangumi/subject/${subjectId}/topics?limit=30`);
                const result = await response.json();
                
                loading.style.display = 'none';
                
                if (result.status === 'success' && result.data.length > 0) {
                    const topics = result.data;
                    topics.forEach(topic => {
                        const topicDiv = document.createElement('div');
                        topicDiv.className = 'topic-item';
                        
                        // è½¬æ¢æ—¶é—´æˆ³ä¸ºå¯è¯»æ ¼å¼
                        const createDate = topic.timestamp ? new Date(topic.timestamp * 1000).toLocaleDateString('zh-CN') : '';
                        const lastpostDate = topic.lastpost ? new Date(topic.lastpost * 1000).toLocaleDateString('zh-CN') : '';
                        
                        topicDiv.innerHTML = `
                            <div class="topic-header">
                                <span class="topic-title" onclick="window.open('${topic.url || `https://bgm.tv/subject/topic/${topic.id}`}', '_blank')">
                                    ğŸ“Œ ${topic.title || 'æ— æ ‡é¢˜'}
                                </span>
                                <span class="topic-meta">
                                    ${createDate}
                                </span>
                            </div>
                            <div class="topic-info">
                                <span class="topic-user">ğŸ‘¤ ${topic.user?.nickname || topic.user?.username || 'åŒ¿å'}</span>
                                <span class="topic-replies">ğŸ’¬ ${topic.replies || 0} å›å¤</span>
                                ${lastpostDate ? `<span class="topic-lastpost">æœ€åå›å¤: ${lastpostDate}</span>` : ''}
                            </div>
                        `;
                        container.appendChild(topicDiv);
                    });
                    
                    // æ·»åŠ æŸ¥çœ‹æ›´å¤šæŒ‰é’®
                    const moreBtn = document.createElement('button');
                    moreBtn.className = 'load-more-btn';
                    moreBtn.textContent = 'åœ¨ Bangumi æŸ¥çœ‹æ›´å¤šè®¨è®º';
                    moreBtn.onclick = () => {
                        window.open(`https://bgm.tv/subject/${subjectId}/board`, '_blank');
                    };
                    container.appendChild(moreBtn);
                } else {
                    container.innerHTML = '<p class="no-data">æš‚æ— è®¨è®ºè¯é¢˜</p>';
                }
            } catch (error) {
                loading.style.display = 'none';
                container.innerHTML = '<p class="error">åŠ è½½å¤±è´¥</p>';
                console.error('åŠ è½½è®¨è®ºè¯é¢˜å¤±è´¥:', error);
            }
        }

        // åŠ è½½ç”¨æˆ·è¯„è®º
        async function loadComments(subjectId) {
            const container = document.getElementById('comments-list');
            const loading = document.getElementById('comments-loading');
            
            loading.style.display = 'block';
            container.innerHTML = '';
            
            try {
                const response = await fetch(`/api/bangumi/subject/${subjectId}/comments?limit=20`);
                const result = await response.json();
                
                loading.style.display = 'none';
                
                if (result.status === 'success' && result.data.length > 0) {
                    const blogs = result.data;
                    blogs.forEach(blog => {
                        const commentDiv = document.createElement('div');
                        commentDiv.className = 'comment-item';
                        
                        const user = blog.user || {};
                        // è½¬æ¢æ—¶é—´æˆ³ä¸ºå¯è¯»æ ¼å¼
                        const dateStr = blog.dateline || (blog.timestamp ? new Date(blog.timestamp * 1000).toLocaleDateString('zh-CN') : '');
                        
                        commentDiv.innerHTML = `
                            <div class="comment-header">
                                <div class="comment-user">
                                    ${user.avatar?.small ? `<img src="${user.avatar.small}" alt="${user.nickname}" class="user-avatar">` : ''}
                                    <span class="user-name">${user.nickname || user.username || 'åŒ¿å'}</span>
                                </div>
                            </div>
                            <div class="comment-title">
                                <a href="${blog.url || '#'}" target="_blank">${blog.title || 'æ— æ ‡é¢˜'}</a>
                            </div>
                            <div class="comment-content">${blog.summary || 'æ— å†…å®¹æ‘˜è¦'}</div>
                            <div class="comment-meta">
                                ${dateStr}
                                ${blog.replies ? ` | ğŸ’¬ ${blog.replies} å›å¤` : ''}
                            </div>
                        `;
                        container.appendChild(commentDiv);
                    });
                    
                    // æ·»åŠ æŸ¥çœ‹æ›´å¤šæŒ‰é’®
                    const moreBtn = document.createElement('button');
                    moreBtn.className = 'load-more-btn';
                    moreBtn.textContent = 'åœ¨ Bangumi æŸ¥çœ‹æ›´å¤šæ—¥å¿—';
                    moreBtn.onclick = () => {
                        window.open(`https://bgm.tv/subject/${subjectId}/reviews`, '_blank');
                    };
                    container.appendChild(moreBtn);
                } else {
                    container.innerHTML = '<p class="no-data">æš‚æ— è¯„è®ºæ—¥å¿—</p>';
                }
            } catch (error) {
                loading.style.display = 'none';
                container.innerHTML = '<p class="error">åŠ è½½å¤±è´¥</p>';
                console.error('åŠ è½½ç”¨æˆ·è¯„è®ºå¤±è´¥:', error);
            }
        }

        // æŸ¥çœ‹è¯é¢˜è¯¦æƒ…ï¼ˆæ‰“å¼€æ–°çª—å£ï¼‰
        function viewTopicDetail(topicId) {
            window.open(`https://bgm.tv/subject/topic/${topicId}`, '_blank');
        }

        // æ–°å¢åŠŸèƒ½ï¼šå…³é—­ç•ªå‰§è¯¦æƒ…
        function closeAnimeDetail() {
            document.getElementById('anime-detail-viewer').classList.add('hidden');
            window.currentAnimeDetail = null;
        }
    </script>
</body>
</html>